package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"time"

	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
)

// API配置
const (
	APIBaseURL = "http://127.0.0.1:36363"
	APITimeout = 30 * time.Second
)

// Job结构体 - 映射后端API的数据结构
type Job struct {
	ID          uint      `json:"id"`
	Name        string    `json:"name"`
	Desc        string    `json:"desc"`
	CronExpr    string    `json:"cron_expr"`
	Mode        string    `json:"mode"`
	Command     string    `json:"command"`
	State       int       `json:"state"` // 0等待 1运行中 2已停止
	MaxRunCount uint      `json:"max_run_count"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// API响应结构
type APIResponse struct {
	Code int         `json:"code"`
	Msg  string      `json:"msg"`
	Data interface{} `json:"data"`
}

// 分页响应结构
type PageResponse struct {
	Code  int    `json:"code"`
	Msg   string `json:"msg"`
	Data  []Job  `json:"data"`
	Total int64  `json:"total"`
	Pages int64  `json:"pages"`
	Page  int    `json:"page"`
	Size  int    `json:"size"`
}

// HTTP客户端
var httpClient = &http.Client{
	Timeout: APITimeout,
}

func main() {
	// Create a new MCP server
	s := server.NewMCPServer(
		"Xiaohu Jobs MCP",
		"1.0.0",
		server.WithToolCapabilities(true),
		server.WithResourceCapabilities(true, true),
		server.WithPromptCapabilities(true),
	)

	// Add tools
	addTools(s)

	// Add resources
	addResources(s)

	// Add prompts
	addPrompts(s)

	// Start the stdio server
	if err := server.ServeStdio(s); err != nil {
		fmt.Printf("Server error: %v\n", err)
	}
}

func addTools(s *server.MCPServer) {
	// List jobs tool
	s.AddTool(mcp.NewTool("list_jobs",
		mcp.WithDescription("List all jobs with optional filtering"),
		mcp.WithNumber("page",
			mcp.Description("Page number for pagination"),
			mcp.DefaultNumber(1),
		),
		mcp.WithNumber("size",
			mcp.Description("Number of jobs per page"),
			mcp.DefaultNumber(10),
		),
		mcp.WithString("state",
			mcp.Description("Filter by job state (0等待 1运行中 2已停止)"),
			mcp.DefaultString(""),
		),
		mcp.WithString("name",
			mcp.Description("Filter by job name"),
			mcp.DefaultString(""),
		),
	), listJobsTool)

	// Get job tool
	s.AddTool(mcp.NewTool("get_job",
		mcp.WithDescription("Get details of a specific job"),
		mcp.WithString("job_id",
			mcp.Description("ID of the job to retrieve"),
			mcp.Required(),
		),
	), getJobTool)

	// Create job tool
	s.AddTool(mcp.NewTool("create_job",
		mcp.WithDescription("Create a new job"),
		mcp.WithString("name",
			mcp.Description("Name of the job"),
			mcp.Required(),
		),
		mcp.WithString("command",
			mcp.Description("Command to execute"),
			mcp.Required(),
		),
		mcp.WithString("cron_expr",
			mcp.Description("Schedule in cron format"),
			mcp.DefaultString(""),
		),
		mcp.WithString("mode",
			mcp.Description("Execution mode: command, http, func"),
			mcp.DefaultString("command"),
		),
		mcp.WithNumber("max_run_count",
			mcp.Description("Maximum number of times to run"),
			mcp.DefaultNumber(0),
		),
	), createJobTool)

	// Update job tool
	s.AddTool(mcp.NewTool("update_job",
		mcp.WithDescription("Update an existing job"),
		mcp.WithString("job_id",
			mcp.Description("ID of the job to update"),
			mcp.Required(),
		),
		mcp.WithString("name",
			mcp.Description("New name of the job"),
		),
		mcp.WithString("command",
			mcp.Description("New command to execute"),
		),
		mcp.WithString("cron_expr",
			mcp.Description("New schedule in cron format"),
		),
		mcp.WithString("mode",
			mcp.Description("New execution mode: command, http, func"),
		),
		mcp.WithNumber("max_run_count",
			mcp.Description("New maximum run count"),
		),
	), updateJobTool)

	// Delete job tool
	s.AddTool(mcp.NewTool("delete_job",
		mcp.WithDescription("Delete a job"),
		mcp.WithString("job_id",
			mcp.Description("ID of the job to delete"),
			mcp.Required(),
		),
	), deleteJobTool)

	// Start job tool
	s.AddTool(mcp.NewTool("start_job",
		mcp.WithDescription("Start a job"),
		mcp.WithString("job_id",
			mcp.Description("ID of the job to start"),
			mcp.Required(),
		),
	), startJobTool)

	// Stop job tool
	s.AddTool(mcp.NewTool("stop_job",
		mcp.WithDescription("Stop a running job"),
		mcp.WithString("job_id",
			mcp.Description("ID of the job to stop"),
			mcp.Required(),
		),
	), stopJobTool)

	// Get job logs tool
	s.AddTool(mcp.NewTool("get_job_logs",
		mcp.WithDescription("Get logs for a specific job"),
		mcp.WithString("job_id",
			mcp.Description("ID of the job"),
			mcp.Required(),
		),
		mcp.WithNumber("limit",
			mcp.Description("Number of log entries to return"),
			mcp.DefaultNumber(10),
		),
	), getJobLogsTool)
}

func addResources(s *server.MCPServer) {
	// Health check resource
	s.AddResource(mcp.NewResource("xiaohu://health",
		"System Health",
		mcp.WithMIMEType("application/json"),
	), handleHealthResource)

	// Jobs overview resource
	s.AddResource(mcp.NewResource("xiaohu://jobs/overview",
		"Jobs Overview",
		mcp.WithMIMEType("application/json"),
	), handleJobsOverviewResource)

	// System config resource
	s.AddResource(mcp.NewResource("xiaohu://config",
		"System Configuration",
		mcp.WithMIMEType("application/json"),
	), handleConfigResource)
}

func addPrompts(s *server.MCPServer) {
	// Job analysis prompt
	s.AddPrompt(mcp.NewPrompt("job_analysis",
		mcp.WithPromptDescription("Analyze job performance and provide insights"),
		mcp.WithArgument("job_id",
			mcp.ArgumentDescription("ID of the job to analyze"),
			mcp.RequiredArgument(),
		),
	), jobAnalysisPrompt)

	// System health report prompt
	s.AddPrompt(mcp.NewPrompt("system_health_report",
		mcp.WithPromptDescription("Generate a comprehensive system health report"),
	), systemHealthReportPrompt)

	// Cron expression helper prompt
	s.AddPrompt(mcp.NewPrompt("cron_helper",
		mcp.WithPromptDescription("Help create and validate cron expressions"),
		mcp.WithArgument("description",
			mcp.ArgumentDescription("Description of the schedule you want"),
			mcp.RequiredArgument(),
		),
	), cronHelperPrompt)
}

// HTTP请求辅助函数
func makeAPIRequest(method, endpoint string, body io.Reader) (*http.Response, error) {
	url := APIBaseURL + endpoint
	req, err := http.NewRequest(method, url, body)
	if err != nil {
		return nil, err
	}

	if body != nil {
		req.Header.Set("Content-Type", "application/json")
	}

	return httpClient.Do(req)
}

// 状态映射函数
func mapStateToStatus(state int) string {
	switch state {
	case 0:
		return "waiting"
	case 1:
		return "running"
	case 2:
		return "stopped"
	default:
		return "unknown"
	}
}

// Tool handlers
func listJobsTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	page := int(request.GetFloat("page", 1))
	size := int(request.GetFloat("size", 10))
	state := request.GetString("state", "")
	name := request.GetString("name", "")

	// 构建查询参数
	endpoint := fmt.Sprintf("/jobs/list?page=%d&size=%d", page, size)
	if state != "" {
		endpoint += "&state=" + state
	}
	if name != "" {
		endpoint += "&name=" + name
	}

	resp, err := makeAPIRequest("GET", endpoint, nil)
	if err != nil {
		return mcp.NewToolResultError("Failed to connect to API: " + err.Error()), nil
	}
	defer resp.Body.Close()

	var pageResp PageResponse
	if err := json.NewDecoder(resp.Body).Decode(&pageResp); err != nil {
		return mcp.NewToolResultError("Failed to parse API response: " + err.Error()), nil
	}

	if pageResp.Code != 200 {
		return mcp.NewToolResultError("API error: " + pageResp.Msg), nil
	}

	// 转换数据格式
	var jobs []map[string]interface{}
	for _, job := range pageResp.Data {
		jobs = append(jobs, map[string]interface{}{
			"id":            strconv.Itoa(int(job.ID)),
			"name":          job.Name,
			"desc":          job.Desc,
			"command":       job.Command,
			"schedule":      job.CronExpr,
			"mode":          job.Mode,
			"status":        mapStateToStatus(job.State),
			"state":         job.State,
			"max_run_count": job.MaxRunCount,
			"created_at":    job.CreatedAt.Format(time.RFC3339),
			"updated_at":    job.UpdatedAt.Format(time.RFC3339),
		})
	}

	result := map[string]interface{}{
		"jobs":     jobs,
		"total":    pageResp.Total,
		"page":     pageResp.Page,
		"size":     pageResp.Size,
		"pages":    pageResp.Pages,
		"has_more": int(pageResp.Page) < int(pageResp.Pages),
	}

	jsonData, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(jsonData)), nil
}

func getJobTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	jobID := request.GetString("job_id", "")
	if jobID == "" {
		return mcp.NewToolResultError("job_id is required"), nil
	}

	endpoint := fmt.Sprintf("/jobs/read?id=%s", jobID)
	resp, err := makeAPIRequest("GET", endpoint, nil)
	if err != nil {
		return mcp.NewToolResultError("Failed to connect to API: " + err.Error()), nil
	}
	defer resp.Body.Close()

	var apiResp APIResponse
	if err := json.NewDecoder(resp.Body).Decode(&apiResp); err != nil {
		return mcp.NewToolResultError("Failed to parse API response: " + err.Error()), nil
	}

	if apiResp.Code != 200 {
		return mcp.NewToolResultError("API error: " + apiResp.Msg), nil
	}

	// 转换数据格式
	jobData, _ := json.Marshal(apiResp.Data)
	var job Job
	json.Unmarshal(jobData, &job)

	result := map[string]interface{}{
		"id":            strconv.Itoa(int(job.ID)),
		"name":          job.Name,
		"desc":          job.Desc,
		"command":       job.Command,
		"schedule":      job.CronExpr,
		"mode":          job.Mode,
		"status":        mapStateToStatus(job.State),
		"state":         job.State,
		"max_run_count": job.MaxRunCount,
		"created_at":    job.CreatedAt.Format(time.RFC3339),
		"updated_at":    job.UpdatedAt.Format(time.RFC3339),
	}

	jsonData, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(jsonData)), nil
}

func createJobTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	name := request.GetString("name", "")
	command := request.GetString("command", "")
	cronExpr := request.GetString("cron_expr", "")
	mode := request.GetString("mode", "command")
	maxRunCount := int(request.GetFloat("max_run_count", 0))

	if name == "" || command == "" {
		return mcp.NewToolResultError("name and command are required"), nil
	}

	jobData := map[string]interface{}{
		"name":          name,
		"command":       command,
		"cron_expr":     cronExpr,
		"mode":          mode,
		"max_run_count": maxRunCount,
		"state":         0,
	}

	jsonData, _ := json.Marshal(jobData)
	resp, err := makeAPIRequest("POST", "/jobs/add", bytes.NewBuffer(jsonData))
	if err != nil {
		return mcp.NewToolResultError("Failed to connect to API: " + err.Error()), nil
	}
	defer resp.Body.Close()

	var apiResp APIResponse
	if err := json.NewDecoder(resp.Body).Decode(&apiResp); err != nil {
		return mcp.NewToolResultError("Failed to parse API response: " + err.Error()), nil
	}

	if apiResp.Code != 200 {
		return mcp.NewToolResultError("API error: " + apiResp.Msg), nil
	}

	return mcp.NewToolResultText(fmt.Sprintf("Job created successfully: %s", apiResp.Msg)), nil
}

func updateJobTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	jobID := request.GetString("job_id", "")
	if jobID == "" {
		return mcp.NewToolResultError("job_id is required"), nil
	}

	updateData := map[string]interface{}{
		"id": jobID,
	}

	if name := request.GetString("name", ""); name != "" {
		updateData["name"] = name
	}
	if command := request.GetString("command", ""); command != "" {
		updateData["command"] = command
	}
	if cronExpr := request.GetString("cron_expr", ""); cronExpr != "" {
		updateData["cron_expr"] = cronExpr
	}
	if mode := request.GetString("mode", ""); mode != "" {
		updateData["mode"] = mode
	}
	if maxRunCount := int(request.GetFloat("max_run_count", -1)); maxRunCount >= 0 {
		updateData["max_run_count"] = maxRunCount
	}

	jsonData, _ := json.Marshal(updateData)
	resp, err := makeAPIRequest("POST", "/jobs/edit", bytes.NewBuffer(jsonData))
	if err != nil {
		return mcp.NewToolResultError("Failed to connect to API: " + err.Error()), nil
	}
	defer resp.Body.Close()

	var apiResp APIResponse
	if err := json.NewDecoder(resp.Body).Decode(&apiResp); err != nil {
		return mcp.NewToolResultError("Failed to parse API response: " + err.Error()), nil
	}

	if apiResp.Code != 200 {
		return mcp.NewToolResultError("API error: " + apiResp.Msg), nil
	}

	return mcp.NewToolResultText(fmt.Sprintf("Job %s updated successfully: %s", jobID, apiResp.Msg)), nil
}

func deleteJobTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	jobID := request.GetString("job_id", "")
	if jobID == "" {
		return mcp.NewToolResultError("job_id is required"), nil
	}

	deleteData := map[string]interface{}{
		"id": jobID,
	}

	jsonData, _ := json.Marshal(deleteData)
	resp, err := makeAPIRequest("POST", "/jobs/del", bytes.NewBuffer(jsonData))
	if err != nil {
		return mcp.NewToolResultError("Failed to connect to API: " + err.Error()), nil
	}
	defer resp.Body.Close()

	var apiResp APIResponse
	if err := json.NewDecoder(resp.Body).Decode(&apiResp); err != nil {
		return mcp.NewToolResultError("Failed to parse API response: " + err.Error()), nil
	}

	if apiResp.Code != 200 {
		return mcp.NewToolResultError("API error: " + apiResp.Msg), nil
	}

	return mcp.NewToolResultText(fmt.Sprintf("Job %s deleted successfully: %s", jobID, apiResp.Msg)), nil
}

func startJobTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	jobID := request.GetString("job_id", "")
	if jobID == "" {
		return mcp.NewToolResultError("job_id is required"), nil
	}

	startData := map[string]interface{}{
		"id": jobID,
	}

	jsonData, _ := json.Marshal(startData)
	resp, err := makeAPIRequest("POST", "/jobs/restart", bytes.NewBuffer(jsonData))
	if err != nil {
		return mcp.NewToolResultError("Failed to connect to API: " + err.Error()), nil
	}
	defer resp.Body.Close()

	var apiResp APIResponse
	if err := json.NewDecoder(resp.Body).Decode(&apiResp); err != nil {
		return mcp.NewToolResultError("Failed to parse API response: " + err.Error()), nil
	}

	if apiResp.Code != 200 {
		return mcp.NewToolResultError("API error: " + apiResp.Msg), nil
	}

	return mcp.NewToolResultText(fmt.Sprintf("Job %s started successfully: %s", jobID, apiResp.Msg)), nil
}

func stopJobTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	jobID := request.GetString("job_id", "")
	if jobID == "" {
		return mcp.NewToolResultError("job_id is required"), nil
	}

	stopData := map[string]interface{}{
		"id": jobID,
	}

	jsonData, _ := json.Marshal(stopData)
	resp, err := makeAPIRequest("POST", "/jobs/stop", bytes.NewBuffer(jsonData))
	if err != nil {
		return mcp.NewToolResultError("Failed to connect to API: " + err.Error()), nil
	}
	defer resp.Body.Close()

	var apiResp APIResponse
	if err := json.NewDecoder(resp.Body).Decode(&apiResp); err != nil {
		return mcp.NewToolResultError("Failed to parse API response: " + err.Error()), nil
	}

	if apiResp.Code != 200 {
		return mcp.NewToolResultError("API error: " + apiResp.Msg), nil
	}

	return mcp.NewToolResultText(fmt.Sprintf("Job %s stopped successfully: %s", jobID, apiResp.Msg)), nil
}

func getJobLogsTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	jobID := request.GetString("job_id", "")
	limit := int(request.GetFloat("limit", 10))

	if jobID == "" {
		return mcp.NewToolResultError("job_id is required"), nil
	}

	endpoint := fmt.Sprintf("/jobs/logs?id=%s&limit=%d", jobID, limit)
	resp, err := makeAPIRequest("POST", endpoint, nil)
	if err != nil {
		return mcp.NewToolResultError("Failed to connect to API: " + err.Error()), nil
	}
	defer resp.Body.Close()

	var apiResp APIResponse
	if err := json.NewDecoder(resp.Body).Decode(&apiResp); err != nil {
		return mcp.NewToolResultError("Failed to parse API response: " + err.Error()), nil
	}

	if apiResp.Code != 200 {
		return mcp.NewToolResultError("API error: " + apiResp.Msg), nil
	}

	logsData, _ := json.MarshalIndent(apiResp.Data, "", "  ")
	return mcp.NewToolResultText(string(logsData)), nil
}

// Resource handlers
func handleHealthResource(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
	resp, err := makeAPIRequest("GET", "/jobs/health", nil)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to API: %v", err)
	}
	defer resp.Body.Close()

	var apiResp APIResponse
	if err := json.NewDecoder(resp.Body).Decode(&apiResp); err != nil {
		return nil, fmt.Errorf("failed to parse API response: %v", err)
	}

	if apiResp.Code != 200 {
		return nil, fmt.Errorf("API error: %s", apiResp.Msg)
	}

	healthData, _ := json.MarshalIndent(apiResp.Data, "", "  ")
	return []mcp.ResourceContents{
		mcp.TextResourceContents{
			URI:      "xiaohu://health",
			MIMEType: "application/json",
			Text:     string(healthData),
		},
	}, nil
}

func handleJobsOverviewResource(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
	// 获取任务列表来生成概览
	resp, err := makeAPIRequest("GET", "/jobs/list?page=1&size=1000", nil)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to API: %v", err)
	}
	defer resp.Body.Close()

	var pageResp PageResponse
	if err := json.NewDecoder(resp.Body).Decode(&pageResp); err != nil {
		return nil, fmt.Errorf("failed to parse API response: %v", err)
	}

	if pageResp.Code != 200 {
		return nil, fmt.Errorf("API error: %s", pageResp.Msg)
	}

	// 统计任务状态
	var totalJobs, runningJobs, stoppedJobs, waitingJobs int
	for _, job := range pageResp.Data {
		totalJobs++
		switch job.State {
		case 0:
			waitingJobs++
		case 1:
			runningJobs++
		case 2:
			stoppedJobs++
		}
	}

	overview := map[string]interface{}{
		"total_jobs":   totalJobs,
		"running_jobs": runningJobs,
		"stopped_jobs": stoppedJobs,
		"waiting_jobs": waitingJobs,
		"last_updated": time.Now().Format(time.RFC3339),
	}

	overviewData, _ := json.MarshalIndent(overview, "", "  ")
	return []mcp.ResourceContents{
		mcp.TextResourceContents{
			URI:      "xiaohu://jobs/overview",
			MIMEType: "application/json",
			Text:     string(overviewData),
		},
	}, nil
}

func handleConfigResource(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
	config := map[string]interface{}{
		"server_name": "Xiaohu Jobs System",
		"version":     "1.0.0",
		"api_base":    APIBaseURL,
		"features":    []string{"job_management", "monitoring", "logging", "cron_scheduling"},
		"timezone":    "Local",
		"log_level":   "INFO",
		"mcp_version": "1.0.0",
	}

	configData, _ := json.MarshalIndent(config, "", "  ")
	return []mcp.ResourceContents{
		mcp.TextResourceContents{
			URI:      "xiaohu://config",
			MIMEType: "application/json",
			Text:     string(configData),
		},
	}, nil
}

// Prompt handlers
func jobAnalysisPrompt(ctx context.Context, request mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
	jobID := request.Params.Arguments["job_id"]
	if jobID == "" {
		jobID = "sample-job"
	}

	return &mcp.GetPromptResult{
		Description: "Analyze job performance and provide insights",
		Messages: []mcp.PromptMessage{
			{
				Role: mcp.RoleUser,
				Content: mcp.TextContent{
					Type: "text",
					Text: fmt.Sprintf(`Please analyze the performance of job %s and provide insights on:

1. Execution frequency and patterns
2. Success/failure rates
3. Resource usage trends
4. Optimization recommendations
5. Alert thresholds

Use the available tools to gather detailed information about this job.`, jobID),
				},
			},
		},
	}, nil
}

func systemHealthReportPrompt(ctx context.Context, request mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
	return &mcp.GetPromptResult{
		Description: "Generate a comprehensive system health report",
		Messages: []mcp.PromptMessage{
			{
				Role: mcp.RoleUser,
				Content: mcp.TextContent{
					Type: "text",
					Text: `Please generate a comprehensive system health report including:

1. Overall system status
2. Job execution statistics
3. Resource utilization
4. Error rates and trends
5. Performance metrics
6. Recommendations for improvement

Use the available tools and resources to gather all necessary information.`,
				},
			},
		},
	}, nil
}

func cronHelperPrompt(ctx context.Context, request mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
	description := request.Params.Arguments["description"]
	if description == "" {
		description = "daily backup at 2 AM"
	}

	return &mcp.GetPromptResult{
		Description: "Help create and validate cron expressions",
		Messages: []mcp.PromptMessage{
			{
				Role: mcp.RoleUser,
				Content: mcp.TextContent{
					Type: "text",
					Text: fmt.Sprintf(`I need help creating a cron expression for: %s

Please provide:
1. The correct cron expression
2. Explanation of each field
3. Next 5 execution times
4. Common variations
5. Validation tips

Examples of common cron expressions:
- Every minute: * * * * *
- Daily at 2 AM: 0 2 * * *
- Weekly on Sunday at 3 AM: 0 3 * * 0
- Every 30 minutes: */30 * * * *
- Monthly on 1st at midnight: 0 0 1 * *`, description),
				},
			},
		},
	}, nil
}
